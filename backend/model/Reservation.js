import UndeterminedStatusError from "../../errors/UndeterminedStatusError.js"

/**
 * Represents a reservation for a room.
 * @class
 * @param {Object} params - The parameters for creating a new reservation.
 * @param {number} [params.reservationId] - The unique identifier of the reservation (optional, generated by the database).
 * @param {string} params.title - The title or purpose of the reservation.
 * @param {number} params.roomId - The unique identifier of the room being reserved.
 * @param {string} params.userEmail - The email of the user making the reservation.
 * @param {string} params.date - The date of the reservation (format: 'YYYY-MM-DD').
 * @param {string} params.startTime - The start time of the reservation (format: 'HH:MM:SS').
 * @param {string} params.endTime - The end time of the reservation (format: 'HH:MM:SS').
 * @param {string} params.status - The current status of the reservation. Valid statuses are: 'Confirmed', 'In Progress', 'Completed', 'Cancelled'.
 */
export default class Reservation{
    constructor({
        reservationId, 
        title, 
        roomId, 
        userEmail, 
        date, 
        startTime, 
        endTime, 
        status = "Confirmed"}){
        this.reservationId = reservationId,
        this.title = title,
        this.roomId = roomId,
        this.userEmail = userEmail,
        this.date = this.extractDate(date),
        this.startTime = this.extractTime(startTime),
        this.endTime = this.extractTime(endTime),
        this.status = this.validateStatus(status)
    }

    /**
     * Check if the reservation's start and end time is valid (its start time is before its end).
     * @returns {boolean} whether or not the reservation has valid a valid duration.
     */ 
    hasValidDuration() {
        return this.startTime < this.endTime // will return false of this.startTime >= this.endTime
    }

    /**
     * Check if the reservation's date and time is valid (not in the past).
     * @returns {boolean} whether or not the reservation has valid a valid date and time.
     */ 
    hasNotPassed() {
        // Convert reservation date & time into a Date object
        const reservationDateTime = new Date(`${this.date}T${this.startTime}Z`);

        // Convert to EST (Eastern Time)
        const estTime = new Date().toLocaleString("en-US", { timeZone: "America/New_York" });
        const now = new Date(estTime);

        // Convert both timestamps to seconds
        const reservationSeconds = Math.floor(reservationDateTime.getTime() / 1000);
        const nowSeconds = Math.floor(now.getTime() / 1000);

        return reservationSeconds > nowSeconds;
    }

    /**
     * Check if a reservation conflicts with another on the same day.
     * @param {Reservation} otherReservation possibly conflicting reservation.
     * @returns {boolean} whether this reservation conflicts with the other one.
     */
    conflictsWith(otherReservation){
        if (this.date !== otherReservation.date || this.roomId !== otherReservation.roomId){
            return false
        }

        return !(this.endTime < otherReservation.startTime || this.startTime > otherReservation.endTime);
    }

    /**
     * Converts a database record or API object into a Reservation instance.
     * @param {Object} reservationData - object containing details about the reservation.
     * @param {number} reservationData.reservationId - Unique ID of the reservation.
     * @param {string} reservationData.title - Title or description of the reservation.
     * @param {number} reservationData.roomId - ID of the room associated with the reservation.
     * @param {string} reservationData.userEmail - Email of the user who made the reservation.
     * @param {string} reservationData.date - Date of the reservation (format: "YYYY-MM-DD").
     * @param {string} reservationData.startTime - Start time of the reservation (format: "HH:MM:SS").
     * @param {string} reservationData.endTime - End time of the reservation (format: "HH:MM:SS").
     * @param {string} reservationData.status - Status of the reservation (e.g., "confirmed", "pending", "cancelled").
     * @returns {Reservation} A Reservation object.
     */
    static toModel(reservationData) {
        return new Reservation({
            reservationId: reservationData.reservation_id,
            title: reservationData.title,
            roomId: reservationData.room_id,
            userEmail: reservationData.user_email,
            date: reservationData.date,
            startTime: reservationData.start_time,
            endTime: reservationData.end_time,
            status: reservationData.status
        });
    }

    /**
    * Converts a Reservation instance back to a plain object (for API responses or DB insertion).
    * @returns an object containing the reservation data.
    */
    fromModel() {
        return {
            reservationId: this.reservationId,
            title: this.title,
            roomId: this.roomId,
            userEmail: this.userEmail,
            date: this.date,
            startTime: this.startTime,
            endTime: this.endTime,
            status: this.status
        };
    }

    /**
     * Convert dateTime string to Time string.
     * @param {string} dateTime Date object with the time to be spliced and extracted.
     * @returns {string} time portion of the Date object.
     */
    extractTime(dateTime) {
        const timeRegex = /^\d{2}:\d{2}:\d{2}$/; // Matches HH:MM:SS
        if (timeRegex.test(dateTime)){ // if dateTime is already in a valid format, just return it
            return dateTime
        }
        
        if (dateTime) {
          return new Date(dateTime).toTimeString().split(' ')[0]; // Returns 'HH:mm:ss'
        }

        return '00:00:00'; // Default if the dateTime is invalid or missing
    }

    /**
     * Convert Date object string to date string.
     * @param {string} date Date object with the date to be spliced and extracted.
     * @returns {string} date portion of the Date object.
     */
      extractDate(date) {
        const timeRegex = /^\d{4}-\d{2}-\d{2}$/; // Matches YYYY-MM-SS
        if (timeRegex.test(date)){ // if dateTime is already in a valid format, just return it
            return date
        }
        
        if (date) {
          return new Date(date).toISOString().split('T')[0]; // Returns 'HH:mm:ss'
        }

        return '0000-00-00'; // Default if the dateTime is invalid or missing
    }


    /**
     * validates the status of either a database record or API object
     * @param {string} status status to confirm.
     * @returns {string} 1 of 4 statuses [`Confirmed`, `In Progress`, `Completed`, `Cancelled`].
     */
    validateStatus(status){
        switch (status) {
            case "Confirmed":
                return "Confirmed";
            case "In Progress":
                return "In Progress";
            case "Completed":
                return "Completed";
            case "Cancelled":
                return "Cancelled";
            default:
                throw new UndeterminedStatusError("This reservation has an invalid status")
        }
    }
}