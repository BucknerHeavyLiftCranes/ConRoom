import { ReservationDetailsError, UpdateReservationError } from "../../../errors/ReservationError.js";
import { GetRoomError } from "../../../errors/RoomError.js";
import { getRoomById } from "../../database/roomsTable.js";

/**
 * @class Represents a meeting reservation for a room.
 * @param {Object} params - The parameters for creating a new reservation.
 * @param {number | undefined} [params.reservationId] - The unique identifier of the reservation (optional, generated by the database).
 * @param {string} [params.title] - The title or purpose of the reservation.
 * @param {number} [params.roomId] - The unique identifier of the room being reserved.
 * @param {string} [params.userEmail] - The email of the user making the reservation.
 * @param {string} [params.date] - The date of the reservation (format: 'YYYY-MM-DD').
 * @param {string} [params.start] - The start time of the reservation (format: 'HH:MM').
 * @param {string} [params.end] - The end time of the reservation (format: 'HH:MM').
 * @param {boolean} [params.canceled] - Whether or not the reservation is active.
 */
export default class Reservation{
    constructor({
        reservationId, 
        title, 
        roomId, 
        userEmail, 
        date, 
        start, 
        end,
        canceled
    }) {
        /**@type {number | undefined} */
        this.reservationId = reservationId ? Number(reservationId) : undefined;
        /**@type {string} reservation title. */
        this.title = title;
        /**@type {number} room id for the reservation. */
        this.roomId = Number(roomId);
        /**@type {string} email of the reservation creator. */
        this.userEmail = userEmail;
        /**@type {string} reservation date. */
        this.date = this.extractDate(date);
        /**@type {string} reservation start time. */
        this.start = this.extractTime(start);
        /**@type {string} reservation start time. */
        this.end = this.extractTime(end);
        /**@type {boolean} active status of the reservation. */
        this.canceled = Boolean(canceled);
    }

    /**
     * Check if the reservation's start and end time is valid (its start time is before its end).
     * @returns {boolean} whether or not the reservation has valid a valid duration.
     */ 
    hasValidDuration() {
        return this.start < this.end // will return false of this.start >= this.end
    }

    /**
     * Check if the reservation's date and time is valid (not in the past).
     * @returns {boolean} whether or not the reservation has valid a valid date and time.
     */ 
    hasNotPassed() {
        // Convert reservation date & time into a Date object
        const reservationDateTime = new Date(`${this.date}T${this.start}Z`);

        // Convert to EST (Eastern Time)
        const estTime = new Date().toLocaleString("en-US", { timeZone: "America/New_York" });
        const now = new Date(estTime);

        // Convert both timestamps to seconds
        const reservationSeconds = Math.floor(reservationDateTime.getTime() / 1000);
        const nowSeconds = Math.floor(now.getTime() / 1000);

        return reservationSeconds > nowSeconds;
    }

    
    /**
     * Check if a reservation conflicts with another on the same day.
     * @param {Reservation} otherReservation possibly conflicting reservation.
     * @returns {boolean} whether this reservation conflicts with the other one.
     */
    conflictsWith(otherReservation){
        if (this.date !== otherReservation.date || this.roomId !== otherReservation.roomId){
            return false
        }

        return !(this.end < otherReservation.start || this.start > otherReservation.end);
    }

    /**
     * Determine's if a reservation can be canceled.
     * @returns {boolean} whether a reservation can be canceled.
     */
    isCancelable(){
        return this.status() === "Confirmed" || this.status() === "Canceled"
    }

    /**
     * Toggle the reservation's active status.
     */
    toggleCanceledStatus(){
        if (!this.isCancelable()) {
            throw new UpdateReservationError("This reservation cannot be canceled at this time.")
        }
        this.canceled = !this.canceled
    }
 
    /**
     * Converts a database record or API object into a Reservation instance.
     * @param {Object} reservationData - object containing details about the reservation.
     * @param {number} reservationData.reservation_id - Unique ID of the reservation.
     * @param {string} reservationData.title - Title or description of the reservation.
     * @param {number} reservationData.room_id - ID of the room associated with the reservation.
     * @param {string} reservationData.user_email - Email of the user who made the reservation.
     * @param {string} reservationData.date - Date of the reservation (format: "YYYY-MM-DD").
     * @param {string} reservationData.start_time - Start time of the reservation (format: "HH:MM").
     * @param {string} reservationData.end_time - End time of the reservation (format: "HH:MM").
     * @param {number} reservationData.canceled - Whether or not the reservation is active.
     * @returns {Reservation} A Reservation object.
     */
    static toModel(reservationData) {
        return new Reservation({
            reservationId: reservationData.reservation_id,
            title: reservationData.title,
            roomId: reservationData.room_id,
            userEmail: reservationData.user_email,
            date: reservationData.date,
            start: reservationData.start_time,
            end: reservationData.end_time,
            canceled: reservationData.canceled
        });
    }

    /**
     * Converts a Reservation instance to a MeetingDetails object for frontend use.
     * @returns {Object} MeetingDetails-like object
     */
    async toMeetingDetails() {
        return {
            reservationId: this.reservationId,
            title: this.title,
            roomId: this.roomId,
            /**@type {string} */
            roomName: (await this.getRoom()).roomName,
            userEmail: this.userEmail,
            date: this.date,
            start: this.start,
            end: this.end,
            canceled: this.canceled,
        }
    }

    /**
    * Converts a Reservation instance back to a plain object (for DB insertion).
    * @returns an object containing the reservation data.
    */
    fromModel() {
        // status does not need to be included as it's not a column in the database.
        return {
            reservationId: this.reservationId,
            title: this.title,
            roomId: this.roomId,
            userEmail: this.userEmail,
            date: this.date,
            start: this.start,
            end: this.end,
            canceled: this.canceled ? 1 : 0
        };
    }

    /**
     * Convert dateTime string to Time string.
     * @param {string} dateTime Date object with the time to be spliced and extracted.
     * @returns {string} time portion of the Date object.
     */
    extractTime(dateTime) {
        const timeRegex = /^\d{2}:\d{2}$/; // Matches HH:MM
        if (timeRegex.test(dateTime)){ // if dateTime is already in a valid format, just return it
            return dateTime
        }

        if (dateTime) {
            return new Date(dateTime)
                .toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit", hour12: false }); // Returns 'HH:mm'
        }

        return '00:00:00'; // Default if the dateTime is invalid or missing
    }

    /**
     * Convert Date object string to date string.
     * @param {string} date Date object with the date to be spliced and extracted.
     * @returns {string} date portion of the Date object.
     */
    extractDate(date) {
        const timeRegex = /^\d{4}-\d{2}-\d{2}$/; // Matches YYYY-MM-SS
        if (timeRegex.test(date)){ // if dateTime is already in a valid format, just return it
            return date
        }
        
        if (date) {
          return new Date(date).toISOString().split('T')[0]; // Returns 'HH:MM'
        }

        return '0000-00-00'; // Default if the dateTime is invalid or missing
    }

    /**
     * Determine reservation's status based on its date and start/end times.
     * @returns {string} 1 of 4 statuses [`Confirmed`, `In Progress`, `Completed`, `Canceled`].
     */
    status(){
        if(this.canceled){
            return "Canceled"
        }

        // Convert reservation date & time into UTC Date object
        const reservationStart = new Date(`${this.date}T${this.start}Z`);
        const reservationEnd = new Date(`${this.date}T${this.end}Z`);

        // Get the current time in UTC
        /**@type {Date} the current time*/
        const now = new Date(new Date().toLocaleString('en-US', { timeZone: 'America/New_York' }));

        // Convert timestamps to seconds
        const reservationStartInSeconds = Math.floor(reservationStart.getTime() / 1000);
        const reservationEndInSeconds = Math.floor(reservationEnd.getTime() / 1000);
        const nowInSeconds = Math.floor(now.getTime() / 1000);

        // Determine status
        if (nowInSeconds < reservationStartInSeconds) {
            return "Confirmed"; // Meeting hasn't started
        } else if (nowInSeconds >= reservationStartInSeconds && nowInSeconds < reservationEndInSeconds) {
            return "In Progress"; // Meeting is ongoing
        } else {
            return "Completed"; // Meeting has ended
        }
    }

    /**
     * Get the room for this reservation.
     * @returns {Promise<Room>} the reservation's room.
     */
    async getRoom(){
        try {
            if (!this.reservationId){
                throw ReservationDetailsError("This reservation is not in the system")
            }

            const room = await getRoomById(this.roomId)
            if (!room) {
                throw new GetRoomError("Failed to fetch the room for this reservation.")
            }

            return room
            
        } catch (err) {
            console.error({ message: err.message, stack: err.stack });
            throw new ReservationDetailsError("Failed to get details for this reservation: ${err}")
        }

    }
}